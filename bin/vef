#!/bin/bash

# TODO -- add out own "enable" command

function printhelp {
cat <<'EOF'
Very Easy Firewall - vef

A very basic firewalling script that allows you to manage sets of rule files and apply them as needed.

USAGE

	vef list

List sets in the default location

	vef apply SETNAME

SETNAME is the name of a set directory in /etc/vefirewall/sets, or a directory containing set data

	vef restore

Restore the last applied set rules.

	vef { enable | disable }

Make vef apply rules at start or not

## Sets

Example `input` set file

	#%POLICY=DROP

	# Normal HTTP traffic on any interface
	80 443

	# Accept alt web on some internal interface eth2 only
	%eth2 8080

	# DNS packets
	53ut

## SSH

By default, the port of the SSH daemon is detected and added to the allowed incoming ports. To cancel this behaviour, set the NOSSH variable:

Example:

	sudo NOSSH=true vef apply default

## Firewall startup

Enable vef on startup by using:

	sudo systemctl enable vef

Any time you invoke `vef apply`, the newly applied firewall set is saved as the latest set.

To not save the new set, use

	sudo NOSAVE=true vef apply SETNAME


EOF
}

GLOBALSETS=/etc/vefirewall/sets
SAVEPATH=/etc/vefirewall/savedset

: ${EDITOR=nano}

# --------- General firewall operations --------------

function allowestablished {
	iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
	iptables -A INPUT -p icmp -j ACCEPT
	iptables -A INPUT -i lo -j ACCEPT

	iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
	iptables -A OUTPUT -p icmp -j ACCEPT
}

function resetfirewall {
	mkdir -p /etc/vefirewall/oldrules
	iptables-save > "/etc/vefirewall/oldrules/save-$(date +"%F%T")"

	iptables -P OUTPUT ACCEPT
	iptables -P INPUT ACCEPT
	iptables -F

	iptables -t nat -F
}

function allowport {
	local CHAIN="$1"
	local tlayer="$2"
	local port="$3"
	local interface="$4"

	if [[ -n "$interface" ]]; then
		interface="-i $interface"
	fi

	iptables -A "$CHAIN" -m state $interface --state NEW -p "$tlayer" --dport "$port" -j ACCEPT
}

function readreallines {
	local TFILE="$1"

	grep -P -v '^(\s*)(#.*)?$' "$TFILE" | sed -r 's/#.*$//'
}

# ------- Set management -------

function issetdir {
	local theset="$1"
	([[ -f "$theset/input" ]] && [[ -f "$theset/output" ]]) || return 1

	([[ -n "$(readpolicy "$theset/input")" ]] && [[ -n "$(readpolicy "$theset/output")" ]]) || return 1

	return 0
}

function getset {
	local expectedsetdir="$GLOBALSETS/$1"
	if issetdir "$expectedsetdir"; then
		echo "$GLOBALSETS/$1"

	elif issetdir "$1"; then
		echo "$1"

	fi
}

function saveset {
	local TARGETSET="$(getset "$1")"

	if [[ "${NOSAVE}" != true ]] && [[ "$TARGETSET" != "$SAVEPATH" ]]; then
		rm -rf "$SAVEPATH" || return 1
		cp "$TARGETSET" -r "$SAVEPATH" || return 2
		echo "Set saved."
	fi
}

# ----------- SSH assurance --------------

function getsshport {
	egrep '^Port' /etc/ssh/sshd_config |head -n 1|sed -r 's/^Port\s+//'
}

function allowssh {
	local sshport="$(getsshport)"
	if [[ -n "$sshport" ]]; then
		allowport INPUT tcp "$sshport"
	fi
}

# ---------- Chain rules application --------------

function applyportrule {
	local INTERFACE="$1"
	local portdef="$2"

	if [[ "$portdef" =~ $(echo "([0-9]+)([ut]*)") ]]; then
		local port="${BASH_REMATCH[1]}"
		local tlayers="${BASH_REMATCH[2]}"
		
		if [[ "$tlayers" =~ t ]] || [[ -z "$tlayers" ]]; then
			allowport "$CHAIN" tcp "$port" "$INTERFACE"
		fi
		
		if [[ "$tlayers" =~ u ]]; then
			allowport "$CHAIN" udp "$port" "$INTERFACE"
		fi
	fi
}

function applychainrules {
	local CHAIN="$1"; shift
	local INTERFACE=

	if [[ "$1" =~ ^% ]]; then
		INTERFACE="${1:1}"
		shift
	fi

	for portdef in "$@"; do
		applyportrule "$INTERFACE" "$portdef"
	done
}

function applyfilerules {
	local CHAIN="$1"
	local RULEFILE="$2"
	local inline=

	readreallines "$RULEFILE"|while read inline; do
		applychainrules "$CHAIN" $inline # do not quote $inline
	done
}

# ------ Policy R/W operations ------

function readpolicy {
	local TFILE="$1"

	if [[ -f "$TFILE" ]]; then
		egrep '^#%POLICY=' "$TFILE" | sed -r 's/^#%POLICY=//'
	fi
}

function setpolicy {
	local CHAIN="$1"
	local POLICY="$2"

	if [[ -n "$POLICY" ]] && [[ "$POLICY" =~ $(echo "ACCEPT|DROP") ]]; then
		iptables -P "$CHAIN" "$POLICY"
	elif [[ -z "$POLICY" ]]; then
		: "No policy"
	else
		echo "Bad policy [$POLICY]" >&2
	fi
}

# --------- Raw rules processing -------------

function setrawrules {
	local TFILE="$1"
	local inline=

	if [[ ! -f "$TFILE" ]]; then return ; fi

	readreallines "$TFILE"|while read inline; do
		# It SHOULD be safe to just execute this since ";" and "$()" and "|" etc are strings that are not evaluated at this point.
		iptables $inline
	done
}

# ------- Set Application --------------

function applyset {
	local SETDIR="$1"
	
	resetfirewall
	allowestablished

	if [[ -z "${NOSSH:-}" ]]; then
		allowssh
	fi

	setrawrules "$SETDIR/rawpre"

	applyfilerules INPUT "$SETDIR/input"
	setpolicy INPUT "$(readpolicy "$SETDIR/input")"

	applyfilerules OUTPUT "$SETDIR/output"
	setpolicy OUTPUT "$(readpolicy "$SETDIR/output")"

	setrawrules "$SETDIR/rawpost"

	setpolicy FORWARD "$(readpolicy "$SETDIR/forward")"
}


function executeset {
	local targetset="$(getset "$1")"

	if [[ -d "$targetset" ]]; then
		applyset "$targetset"
	else
		echo "Could not find set to apply." >&2
		exit 1
	fi

	echo "Done."
}

function applyactiveset {
	if [[ -d "$SAVEPATH" ]]; then
		executeset "$SAVEPATH"
	else
		echo "vefirewall: No saved set exists"
	fi
}

# --- Set Handling ---

function listsets {
	local theset=
	for theset in "$GLOBALSETS"/*; do
		if issetdir "$theset"; then
			echo "${theset##*/}"
		fi
	done
}

function editset {
	case "$1" in
	input|output|forward|rawpre|rawpost)
		"$EDITOR" "$SAVEPATH/$2"
		;;
	*)
		echo 'Invalid section' >&2
		exit 3
		;;
	esac
}

# --- Main ---

function needroot {
	if [[ "$UID" != 0 ]]; then
		echo "You must be root to run this script"
		exit 1
	fi
}

if [[ -z "$*" ]]; then
	printhelp

elif [[ "$1" = enable ]]; then
	needroot
	systemctl enable vef

elif [[ "$1" = disable ]]; then
	needroot
	systemctl disable vef

elif [[ "$1" = restore ]]; then
	needroot
	applyactiveset

elif [[ "$1" = apply ]]; then
	needroot
	if [[ -n "$2" ]]; then
		loadset "$2"
	fi
	applyactiveset

elif [[ "$1" = load ]]; then
	needroot
	loadset "$2"

elif [[ "$1" = edit ]]; then
	needroot
	editset "$2"

elif [[ "$1" = list ]]; then
	needroot
	listsets
else
	echo "Unknown command [$1]" >&2
fi
