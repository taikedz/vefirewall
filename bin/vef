#!/bin/bash

function printhelp {
cat <<'EOF'
Very Easy Firewall - vef

A very basic firewalling script that allows you to manage sets of rule files and apply them as needed.

USAGE

	vef list
	vef apply SETNAME

SETNAME is the name of a set directory in /etc/vefirewall/sets

## Sets

Example `input` set file

	#%POLICY=DROP

	# Normal HTTP traffic on any interface
	80 443

	# Accept alt web on some internal interface eth2 only
	%eth2 8080

	# DNS packets
	53ut

## SSH

By default, the port of the SSH daemon is detected and added to the allowed incoming ports. To cancel this behaviour, set the NOSSH variable:

Example:

	sudo NOSSH=true vef apply default

## Firewall startup

Enable vef on startup by using:

	sudo systemctl enable vef

Any time you invoke `vef apply`, the newly applied firewall set is saved as the latest set.

To not save the new set, use

	sudo NOSAVE=true vef apply SETNAME


EOF
}

GLOBALSETS=/etc/vefirewall/sets

function allowestablished {
	iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
	iptables -A INPUT -p icmp -j ACCEPT
	iptables -A INPUT -i lo -j ACCEPT

	iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
	iptables -A OUTPUT -p icmp -j ACCEPT
}

function resetfirewall {
	mkdir -p /etc/vefirewall/oldrules
	iptables-save > "/etc/vefirewall/oldrules/save-$(date +"%F%T")"

	iptables -P OUTPUT ACCEPT
	iptables -P INPUT ACCEPT
	iptables -F

	iptables -t nat -F
}

function allowport {
	local CHAIN="$1"
	local tlayer="$2"
	local port="$3"
	local interface="$4"

	if [[ -n "$interface" ]]; then
		interface="-i $interface"
	fi

	iptables -A "$CHAIN" -m state $interface --state NEW -p "$tlayer" --dport "$port" -j ACCEPT
}

function getsshport {
	egrep '^Port' /etc/ssh/sshd_config |head -n 1|sed -r 's/^Port\s+//'
}

function allowssh {
	local sshport="$(getsshport)"
	if [[ -n "$sshport" ]]; then
		allowport INPUT tcp "$sshport"
	fi
}

function applychainrules {
	local CHAIN="$1"; shift
	local INTERFACE=

	if [[ "$1" =~ ^% ]]; then
		INTERFACE="${1:1}"
		shift
	fi

	for portdef in "$@"; do
		if [[ "$portdef" =~ $(echo "([0-9]+)([ut]*)") ]]; then
			local port="${BASH_REMATCH[1]}"
			local tlayers="${BASH_REMATCH[2]}"
			
			if [[ "$tlayers" =~ t ]]; then
				allowport "$CHAIN" tcp "$port" "$INTERFACE"
			fi
			
			if [[ "$tlayers" =~ u ]]; then
				allowport "$CHAIN" udp "$port" "$INTERFACE"
			fi
		fi
	done
}

function readreallines {
	local TFILE="$1"

	grep -P -v '^(\s*)(#.*)?$' "$TFILE" | sed -r 's/#.*$//'
}

function applyfilerules {
	local CHAIN="$1"
	local RULEFILE="$2"
	local inline=

	readreallines "$RULEFILE"|while read inline; do
		applychainrules "$CHAIN" $inline # do not quote $inline
	done
}

function readpolicy {
	local TFILE="$1"

	if [[ -f "$TFILE" ]]; then
		egrep '^#%POLICY=' "$TFILE" | sed -r 's/^#%POLICY=//'
	fi
}

function setpolicy {
	local CHAIN="$1"
	local POLICY="$2"

	if [[ -n "$POLICY" ]] && [[ "$POLICY" =~ $(echo "ACCEPT|DROP") ]]; then
		iptables -P "$CHAIN" "$POLICY"
	elif [[ -z "$POLICY" ]]; then
		: "No policy"
	else
		echo "Bad policy [$POLICY]" >&2
	fi
}

function setrawrules {
	local TFILE="$1"
	local inline=

	if [[ ! -f "$TFILE" ]]; then return ; fi

	readreallines "$TFILE"|while read inline; do
		# It SHOULD be safe to just execute this since ";" and "$()" and "|" etc are strings that are not evaluated at this point.
		iptables $inline
	done
}

function applyset {
	local SETDIR="$1"
	
	resetfirewall
	allowestablished

	if [[ -z "${NOSSH:-}" ]]; then
		allowssh
	fi

	setrawrules "$SETDIR/rawpre"

	applyfilerules INPUT "$SETDIR/input"
	setpolicy INPUT "$(readpolicy "$SETDIR/input")"

	applyfilerules OUTPUT "$SETDIR/output"
	setpolicy OUTPUT "$(readpolicy "$SETDIR/output")"

	setrawrules "$SETDIR/rawpost"

	setpolicy FORWARD "$(readpolicy "$SETDIR/forward")"
}

function executeset {
	local targetset="$1"

	if issetdir "$GLOBALSETS/$targetset"; then
		applyset "$GLOBALSETS/$targetset"
	else
		echo "Could not find set to apply." >&2
		exit 1
	fi

	echo "Done."
}

function saveset {
	if [[ "${NOSAVE}" != true ]]; then
		echo "$1" > /etc/vefirewall/savedset
		echo "Set saved."
	fi
}

function issetdir {
	local theset="$1"
	([[ -f "$theset/input" ]] && [[ -f "$theset/output" ]]) || return 1

	([[ -n "$(readpolicy "$theset/input")" ]] && [[ -n "$(readpolicy "$theset/output")" ]]) || return 1

	return 0
}

function listsets {
	local theset=
	for theset in "$GLOBALSETS"/*; do
		if issetdir "$theset"; then
			echo "${theset##*/}"
		fi
	done
}

# --- Main ---

function needroot {
	if [[ "$UID" != 0 ]]; then
		echo "You must be root to run this script"
		exit 1
	fi
}

if [[ -z "$*" ]]; then
	printhelp
elif [[ "$1" = apply ]]; then
	needroot
	executeset "$2" && saveset "$2"
elif [[ "$1" = list ]]; then
	needroot
	listsets
else
	echo "Unknown command [$1]" >&2
fi
