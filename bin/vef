#!/bin/bash

function printhelp {
cat <<'EOF'
Very Easy Firewall - vef

A very basic firewalling script that allows you to manage sets of rule files and apply them as needed.

USAGE

Make vef apply rules at system start or not:

	vef { enable | disable }

List sets in the default location:

	vef list

Load a named set:

	vef load SETNAME

Edit the rule file for the currently loaded set:

	vef edit { input | output | forward | rawpre | rawpost }

Save the active set as a named set:

	vef save SETNAME

Load and apply the named set, or aply a previously loaded set:

	vef apply [SETNAME]

## Sets

Example `input` set rules

	#%POLICY=DROP

	# Normal HTTP traffic on any interface
	80 443

	# Accept alt web on some internal interface eth2 only
	%eth2 8080

	# DNS packets
	53ut

## SSH

By default, the port of the SSH daemon is detected and added to the allowed incoming ports. To cancel this behaviour, set the NOSSH variable:

Example:

	sudo NOSSH=true vef apply default


EOF
}

GLOBALSETS=/etc/vefirewall/sets
SAVEPATH=/etc/vefirewall/savedset

: ${EDITOR=nano}

# --------- General firewall operations --------------

function allowestablished {
	iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
	iptables -A INPUT -p icmp -j ACCEPT
	iptables -A INPUT -i lo -j ACCEPT

	iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
	iptables -A OUTPUT -p icmp -j ACCEPT
}

function resetfirewall {
	mkdir -p /etc/vefirewall/oldrules
	iptables-save > "/etc/vefirewall/oldrules/save-$(date +"%F%T")"

	iptables -P OUTPUT ACCEPT
	iptables -P INPUT ACCEPT
	iptables -F

	iptables -t nat -F
}

function allowport {
	local CHAIN="$1"
	local tlayer="$2"
	local port="$3"
	local interface="$4"

	if [[ -n "$interface" ]]; then
		interface="-i $interface"
	fi

	iptables -A "$CHAIN" -m state $interface --state NEW -p "$tlayer" --dport "$port" -j ACCEPT
}

function readreallines {
	local TFILE="$1"

	grep -P -v '^(\s*)(#.*)?$' "$TFILE" | sed -r 's/#.*$//'
}

# ------- Set management -------

function issetdir {
	local theset="$1"
	([[ -f "$theset/input" ]] && [[ -f "$theset/output" ]]) || return 1

	([[ -n "$(readpolicy "$theset/input")" ]] && [[ -n "$(readpolicy "$theset/output")" ]]) || return 1

	return 0
}

function getset {
	local expectedsetdir="$GLOBALSETS/$1"
	if issetdir "$expectedsetdir"; then
		echo "$GLOBALSETS/$1"

	elif issetdir "$1"; then
		echo "$1"

	fi
}

function loadset {
	local TARGETSET="$(getset "$1")"

	if [[ "$TARGETSET" != "$SAVEPATH" ]]; then
		rm -rf "$SAVEPATH" || return 1
		cp "$TARGETSET" -r "$SAVEPATH" || return 2
		echo "Set $1 loaded."
	fi
}

function storeset {
	local SETNAME="$1"
	local SETPATH="$GLOBALSETS/$SETNAME"

	if [[ -z "$SETNAME" ]]; then
		echo "Name needed" >&2
		exit 4
	fi
	
	if [[ "$(basename "$SETNAME")" != "$SETNAME" ]] || [[ "$SETNAME" =~ $(echo '\.|/') ]]; then
		echo "Invalid set name [$SETNAME]" >&2
		exit 4
	fi

	if [[ -d "$SETPATH" ]]; then
		rm -r "$SETPATH"
	fi

	cp -r "$SAVEPATH" "$SETPATH"
}

# ----------- SSH assurance --------------

function getsshport {
	egrep '^Port' /etc/ssh/sshd_config |head -n 1|sed -r 's/^Port\s+//'
}

function allowssh {
	local sshport="$(getsshport)"
	if [[ -n "$sshport" ]]; then
		allowport INPUT tcp "$sshport"
	fi
}

# ---------- Chain rules application --------------

function applyportrule {
	local INTERFACE="$1"
	local portdef="$2"

	if [[ "$portdef" =~ $(echo "([0-9]+)([ut]*)") ]]; then
		local port="${BASH_REMATCH[1]}"
		local tlayers="${BASH_REMATCH[2]}"
		
		if [[ "$tlayers" =~ t ]] || [[ -z "$tlayers" ]]; then
			allowport "$CHAIN" tcp "$port" "$INTERFACE"
		fi
		
		if [[ "$tlayers" =~ u ]]; then
			allowport "$CHAIN" udp "$port" "$INTERFACE"
		fi
	fi
}

function applychainrules {
	local CHAIN="$1"; shift
	local INTERFACE=

	if [[ "$1" =~ ^% ]]; then
		INTERFACE="${1:1}"
		shift
	fi

	for portdef in "$@"; do
		applyportrule "$INTERFACE" "$portdef"
	done
}

function applyfilerules {
	local CHAIN="$1"
	local RULEFILE="$2"
	local inline=

	readreallines "$RULEFILE"|while read inline; do
		applychainrules "$CHAIN" $inline # do not quote $inline
	done
}

# ------ Policy R/W operations ------

function readpolicy {
	local TFILE="$1"

	if [[ -f "$TFILE" ]]; then
		egrep '^#%POLICY=' "$TFILE" | sed -r 's/^#%POLICY=//'
	fi
}

function setpolicy {
	local CHAIN="$1"
	local POLICY="$2"

	if [[ -n "$POLICY" ]] && [[ "$POLICY" =~ $(echo "ACCEPT|DROP") ]]; then
		iptables -P "$CHAIN" "$POLICY"
	elif [[ -z "$POLICY" ]]; then
		: "No policy"
	else
		echo "Bad policy [$POLICY]" >&2
	fi
}

# --------- Raw rules processing -------------

function setrawrules {
	local TFILE="$1"
	local inline=

	if [[ ! -f "$TFILE" ]]; then return ; fi

	readreallines "$TFILE"|while read inline; do
		# It SHOULD be safe to just execute this since ";" and "$()" and "|" etc are strings that are not evaluated at this point.
		iptables $inline
	done
}

# ------- Set Application --------------

function applyset {
	local SETDIR="$1"
	
	resetfirewall
	allowestablished

	if [[ -z "${NOSSH:-}" ]]; then
		allowssh
	fi

	setrawrules "$SETDIR/rawpre"

	applyfilerules INPUT "$SETDIR/input"
	setpolicy INPUT "$(readpolicy "$SETDIR/input")"

	applyfilerules OUTPUT "$SETDIR/output"
	setpolicy OUTPUT "$(readpolicy "$SETDIR/output")"

	setrawrules "$SETDIR/rawpost"

	setpolicy FORWARD "$(readpolicy "$SETDIR/forward")"
}


function executeset {
	local targetset="$(getset "$1")"

	if [[ -d "$targetset" ]]; then
		applyset "$targetset"
	else
		echo "Could not find set to apply." >&2
		exit 1
	fi

	echo "Done."
}

function applyactiveset {
	if [[ -d "$SAVEPATH" ]]; then
		executeset "$SAVEPATH"
	else
		echo "vefirewall: No saved set exists"
	fi
}

# --- Set Handling ---

function listsets {
	local theset=
	for theset in "$GLOBALSETS"/*; do
		if issetdir "$theset"; then
			echo "${theset##*/}"
		fi
	done
}

function editset {
	case "$1" in
	input|output|forward|rawpre|rawpost)
		"$EDITOR" "$SAVEPATH/$1"
		;;
	*)
		echo 'Invalid section' >&2
		echo 'Valid sections are:'
		echo '  input, output, forward, rawpre, rawpost'
		exit 3
		;;
	esac
}

# --- Main ---

function needroot {
	if [[ "$UID" != 0 ]]; then
		echo "You must be root to run this script"
		exit 1
	fi
}

if [[ -z "$*" ]]; then
	printhelp

elif [[ "$1" = enable ]]; then
	needroot
	systemctl enable vef

elif [[ "$1" = disable ]]; then
	needroot
	systemctl disable vef

elif [[ "$1" = apply ]]; then
	needroot
	if [[ -n "$2" ]]; then
		loadset "$2"
	fi
	applyactiveset

elif [[ "$1" = load ]]; then
	needroot
	loadset "$2"

elif [[ "$1" = save ]]; then
	needroot
	storeset "$2"

elif [[ "$1" = edit ]]; then
	needroot
	editset "$2"

elif [[ "$1" = list ]]; then
	needroot
	listsets
else
	echo "Unknown command [$1]" >&2
fi
